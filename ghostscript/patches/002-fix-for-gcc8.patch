--- a/tesseract/src/api/baseapi.cpp
+++ b/tesseract/src/api/baseapi.cpp
@@ -64,7 +64,6 @@
 #include <cmath>    // for round, M_PI
 #include <cstdint>  // for int32_t
 #include <cstring>  // for strcmp, strcpy
-#include <filesystem> // for std::filesystem
 #include <fstream>  // for size_t
 #include <iostream> // for std::cin
 #include <locale>   // for std::locale::classic
@@ -85,6 +84,12 @@
 #if defined(_WIN32)
 #  include <fcntl.h> // for _O_BINARY
 #  include <io.h>    // for _setmode
+#else
+#include <dirent.h>            // for closedir, opendir, readdir, DIR, dirent
+#include <libgen.h>
+#include <sys/types.h>
+#include <sys/stat.h>          // for stat, S_IFDIR
+#include <unistd.h>
 #endif
 
 namespace tesseract {
@@ -144,18 +149,63 @@ static void ExtractFontName(const char* filename, std::string* fontname) {
 
 /* Add all available languages recursively.
  */
-static void addAvailableLanguages(const std::string &datadir,
-                                  std::vector<std::string> *langs) {
-  for (const auto& entry :
-       std::filesystem::recursive_directory_iterator(datadir,
-         std::filesystem::directory_options::follow_directory_symlink |
-         std::filesystem::directory_options::skip_permission_denied)) {
-    auto path = entry.path().lexically_relative(datadir).string();
-    auto extPos = path.rfind(".traineddata");
-    if (extPos != std::string::npos) {
-      langs->push_back(path.substr(0, extPos));
+static void addAvailableLanguages(const std::string& datadir, const std::string& base,
+                                  std::vector<std::string>* langs)
+{
+  auto base2 = base;
+  if (!base2.empty())
+    base2 += "/";
+  const size_t extlen = sizeof(kTrainedDataSuffix);
+#ifdef _WIN32
+    WIN32_FIND_DATA data;
+    HANDLE handle = FindFirstFile((datadir + base2 + "*").c_str(), &data);
+    if (handle != INVALID_HANDLE_VALUE) {
+      BOOL result = TRUE;
+      for (; result;) {
+        char *name = data.cFileName;
+        // Skip '.', '..', and hidden files
+        if (name[0] != '.') {
+          if ((data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ==
+              FILE_ATTRIBUTE_DIRECTORY) {
+            addAvailableLanguages(datadir, base2 + name, langs);
+          } else {
+            size_t len = strlen(name);
+            if (len > extlen && name[len - extlen] == '.' &&
+                strcmp(&name[len - extlen + 1], kTrainedDataSuffix) == 0) {
+              name[len - extlen] = '\0';
+              langs->push_back(base2 + name);
+            }
+          }
+        }
+        result = FindNextFile(handle, &data);
+      }
+      FindClose(handle);
+    }
+#else  // _WIN32
+  DIR* dir = opendir((datadir + base).c_str());
+  if (dir != nullptr) {
+    dirent *de;
+    while ((de = readdir(dir))) {
+      char *name = de->d_name;
+      // Skip '.', '..', and hidden files
+      if (name[0] != '.') {
+        struct stat st;
+        if (stat((datadir + base2 + name).c_str(), &st) == 0 &&
+            (st.st_mode & S_IFDIR) == S_IFDIR) {
+          addAvailableLanguages(datadir, base2 + name, langs);
+        } else {
+          size_t len = strlen(name);
+          if (len > extlen && name[len - extlen] == '.' &&
+              strcmp(&name[len - extlen + 1], kTrainedDataSuffix) == 0) {
+            name[len - extlen] = '\0';
+            langs->push_back(base2 + name);
+          }
+        }
+      }
     }
+    closedir(dir);
   }
+#endif
 }
 
 TessBaseAPI::TessBaseAPI()
@@ -396,7 +446,7 @@ void TessBaseAPI::GetLoadedLanguagesAsVector(std::vector<std::string> *langs) co
 void TessBaseAPI::GetAvailableLanguagesAsVector(std::vector<std::string> *langs) const {
   langs->clear();
   if (tesseract_ != nullptr) {
-    addAvailableLanguages(tesseract_->datadir, langs);
+    addAvailableLanguages(tesseract_->datadir, "", langs);
     std::sort(langs->begin(), langs->end());
   }
 }
--- a/tesseract/src/ccutil/ccutil.cpp
+++ b/tesseract/src/ccutil/ccutil.cpp
@@ -10,15 +10,29 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#if defined(_WIN32)
+#include <io.h>         // for _access
+#else
+#include <unistd.h>     // for access
+#endif
+
 #include "ccutil.h"
 #include "tprintf.h"  // for tprintf
 
 #include <cstdlib>
 #include <cstring>    // for std::strrchrA
-#include <filesystem> // for std::filesystem
 
 namespace tesseract {
 
+// Replacement for std::filesystem::exists (C++-17)
+static bool file_exists(const char* filename) {
+#if defined(_WIN32)
+  return _access(filename, 0) == 0;
+#else
+  return access(filename, 0) == 0;
+#endif
+}
+
 CCUtil::CCUtil()
     : params_()
       , INT_INIT_MEMBER(ambigs_debug_level, 0, "Debug level for unichar ambiguities", &params_)
@@ -47,7 +61,7 @@ void CCUtil::main_setup(const std::string &argv0, const std::string &basename) {
   const char *tessdata_prefix = getenv("TESSDATA_PREFIX");
 
   // Ignore TESSDATA_PREFIX if there is no matching filesystem entry.
-  if (tessdata_prefix != nullptr && !std::filesystem::exists(tessdata_prefix)) {
+  if (tessdata_prefix != nullptr && !file_exists(tessdata_prefix)) {
     tprintf("Warning: TESSDATA_PREFIX %s does not exist, ignore it\n", tessdata_prefix);
     tessdata_prefix = nullptr;
   }
@@ -59,7 +73,7 @@ void CCUtil::main_setup(const std::string &argv0, const std::string &basename) {
     /* Use tessdata prefix from the environment. */
     datadir = tessdata_prefix;
 #if defined(_WIN32)
-  } else if (datadir.empty() || !std::filesystem::exists(datadir)) {
+  } else if (datadir.empty() || !file_exists(datadir.c_str())) {
     /* Look for tessdata in directory of executable. */
     char path[_MAX_PATH];
     DWORD length = GetModuleFileName(nullptr, path, sizeof(path));
@@ -69,7 +83,7 @@ void CCUtil::main_setup(const std::string &argv0, const std::string &basename) {
         *separator = '\0';
         std::string subdir = path;
         subdir += "/tessdata";
-        if (std::filesystem::exists(subdir)) {
+        if (file_exists(subdir.c_str())) {
           datadir = subdir;
         }
       }
--- a/tesseract/src/training/unicharset_extractor.cpp
+++ b/tesseract/src/training/unicharset_extractor.cpp
@@ -21,7 +21,6 @@
 // a unicharset.
 
 #include <cstdlib>
-#include <filesystem>
 #include "boxread.h"
 #include "commandlineflags.h"
 #include "commontraining.h" // CheckSharedLibraryVersion
@@ -65,21 +64,15 @@ static int Main(int argc, char **argv) {
   UNICHARSET unicharset;
   // Load input files
   for (int arg = 1; arg < argc; ++arg) {
-    std::filesystem::path filePath = argv[arg];
     std::string file_data = tesseract::ReadFile(argv[arg]);
     if (file_data.empty()) {
       continue;
     }
     std::vector<std::string> texts;
-    if (filePath.extension() == ".box") {
+    if (ReadMemBoxes(-1, /*skip_blanks*/ true, &file_data[0],
+                     /*continue_on_failure*/ false, /*boxes*/ nullptr,
+                     &texts, /*box_texts*/ nullptr, /*pages*/ nullptr)) {
       tprintf("Extracting unicharset from box file %s\n", argv[arg]);
-      bool res = ReadMemBoxes(-1, /*skip_blanks*/ true, &file_data[0],
-                   /*continue_on_failure*/ false, /*boxes*/ nullptr, &texts,
-                   /*box_texts*/ nullptr, /*pages*/ nullptr);
-      if (!res) {
-        tprintf("Cannot read box data from '%s'\n", argv[arg]);
-        return EXIT_FAILURE;
-      }
     } else {
       tprintf("Extracting unicharset from plain text file %s\n", argv[arg]);
       texts.clear();
--- a/tesseract/unittest/pagesegmode_test.cc
+++ b/tesseract/unittest/pagesegmode_test.cc
@@ -9,9 +9,14 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+#if defined(_WIN32)
+#include <io.h>         // for _access
+#else
+#include <unistd.h>     // for access
+#endif
+
 #include <allheaders.h>
 #include <tesseract/baseapi.h>
-#include <filesystem>
 #include <string>
 #include "helpers.h"
 #include "include_gunit.h"
@@ -20,6 +25,15 @@
 
 namespace tesseract {
 
+// Replacement for std::filesystem::exists (C++-17)
+static bool file_exists(const char* filename) {
+#if defined(_WIN32)
+  return _access(filename, 0) == 0;
+#else
+  return access(filename, 0) == 0;
+#endif
+}
+
 // The fixture for testing Tesseract.
 class PageSegModeTest : public testing::Test {
 protected:
@@ -73,7 +87,7 @@ protected:
 // and differently to line and block mode.
 TEST_F(PageSegModeTest, WordTest) {
   std::string filename = file::JoinPath(TESTING_DIR, "segmodeimg.tif");
-  if (!std::filesystem::exists(filename)) {
+  if (!file_exists(filename.c_str())) {
     LOG(INFO) << "Skip test because of missing " << filename << '\n';
     GTEST_SKIP();
   } else {
--- a/tesseract/unittest/tatweel_test.cc
+++ b/tesseract/unittest/tatweel_test.cc
@@ -9,7 +9,12 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include <filesystem>
+#if defined(_WIN32)
+#include <io.h>         // for _access
+#else
+#include <unistd.h>     // for access
+#endif
+
 #include "dawg.h"
 #include "include_gunit.h"
 #include "trie.h"
@@ -18,6 +23,15 @@
 
 namespace tesseract {
 
+// Replacement for std::filesystem::exists (C++-17)
+static bool file_exists(const char* filename) {
+#if defined(_WIN32)
+  return _access(filename, 0) == 0;
+#else
+  return access(filename, 0) == 0;
+#endif
+}
+
 class TatweelTest : public ::testing::Test {
 protected:
   void SetUp() override {
@@ -27,7 +41,7 @@ protected:
 
   TatweelTest() {
     std::string filename = TestDataNameToPath("ara.wordlist");
-    if (std::filesystem::exists(filename)) {
+    if (file_exists(filename.c_str())) {
       std::string wordlist("\u0640");
       CHECK_OK(file::GetContents(filename, &wordlist, file::Defaults()));
       // Put all the unicodes in the unicharset_.
@@ -63,7 +77,7 @@ TEST_F(TatweelTest, DictIgnoresTatweel) {
   // This test verifies that the dictionary ignores the Tatweel character.
   tesseract::Trie trie(tesseract::DAWG_TYPE_WORD, "ara", SYSTEM_DAWG_PERM, unicharset_.size(), 0);
   std::string filename = TestDataNameToPath("ara.wordlist");
-  if (!std::filesystem::exists(filename)) {
+  if (!file_exists(filename.c_str())) {
     LOG(INFO) << "Skip test because of missing " << filename;
     GTEST_SKIP();
   } else {
@@ -77,7 +91,7 @@ TEST_F(TatweelTest, UnicharsetLoadKeepsTatweel) {
   // This test verifies that a load of an existing unicharset keeps any
   // existing tatweel for backwards compatibility.
   std::string filename = TestDataNameToPath("ara.unicharset");
-  if (!std::filesystem::exists(filename)) {
+  if (!file_exists(filename.c_str())) {
     LOG(INFO) << "Skip test because of missing " << filename;
     GTEST_SKIP();
   } else {
